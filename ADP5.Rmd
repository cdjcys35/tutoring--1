---
title: "ADP5"
output:
  html_document:
    number_sections: true
    fig_caption: true
    toc: true
    fig_width: 5
    fig_height: 4
    theme: cosmo
    highlight: tango
    code_folding: show
---

20회 복기

```{r}
library(tidyverse)
library(data.table)
library(lubridate)
library(caret)
library(recipes)
library(rsample)
library(forecast)
```

# 시계열 온도 예측 문제 {.tabset .tabset-fade}

## Data description

-   year: 2016 for all data points
-   month: number for month of the year
-   day: number for day of the year
-   week: day of the week as a character string
-   temp_2: max temperature 2 days prior
-   temp_1: max temperature 1 day prior
-   average: historical average max temperature
-   actual: max temperature measurement
-   friend: your friend's prediction, a random number between 20 below the average and 20 above the average

```{r}
temp <- fread("data/temps.csv")
temp %>% str()
```

## 데이터 전처리 (10점)

-   결측값 처리
-   필요 없는 칼럼 처리
-   전처리 완료된 결과 산출
-   train/test set을 어떻게 나눌지 설명

```{r}
temp %>% is.na() %>% colSums()
temp <- temp %>% 
    mutate(date = make_date(year, month, day)) 
    

date_t <- seq(ymd("2016-01-01"), ymd("2016-12-31"), by = "1 day")

date_t %>% length()
temp %>% dim()

temp1 <- date_t %>%
    as_tibble() %>% 
    left_join(temp, by = c("value" = "date")) %>% 
    rename(date = value)

temp1 %>% is.na() %>% colSums()

```

```{r}
rec <- temp1 %>% 
    recipe(actual~.) %>% 
    step_rm(forecast_acc, forecast_noaa, forecast_under, friend, year, month, day, week) %>% 
    step_meanimpute(average, actual, temp_1, temp_2) %>% 
    step_mutate( 
                month = month(date), 
                day = day(date), 
                week = week(date))
    
temp1 <- rec %>% prep() %>% juice()

temp1 %>% is.na() %>% colSums()
```

```{r}

act_ts <- temp1$actual %>% ts()
ggtsdisplay(act_ts)

splits <- initial_time_split(temp1, prop = 0.7)

train <- training(splits)
test <- testing(splits)

```



## Random forest로 검증 및 분석

-   Random forest의 예측한계선을 설정하는 방법을 말하고 어떤 방법을 써야 하는지 기술
-   Random forest를 활용해 예측 및 검증, 파라미터 튜닝으로 성능 강화
-   columns 별 중요도 시각화



**caret time series fold**
-   initialWindow: the initial number of consecutive values in each training set sample
-   horizon: The number of consecutive values in test set sample
-   fixedWindow: A logical: if FALSE, the training set always start at the first sample and the training set size will vary over data splits.

![](images/time.PNG)



```{r}

control <- trainControl(method='timeslice',
                        initialWindow = 64,
                        horizon = 32,
                        fixedWindow = TRUE
                        )

```


```{r}

rf_gridsearch <- train(actual ~ .,             
                       data = train,               
                       method = 'rf',  
                       trControl = control, 
                       metric = 'RMSE',
                       tuneLength = 30) 

plot(varImp(rf_gridsearch, scale = F))


pred <- predict(rf_gridsearch, newdata = test)
print(RMSE(pred, test$actual))

# 예측 한계선 
print(RMSE(test$average, test$actual))

```

## time series split 안했을 때 
```{r}
splits <- initial_split(temp1, prop = 0.7)

train <- training(splits)
test <- testing(splits)

set.seed(123)
control <- trainControl(method='cv', 
                        number=5)


rf_gridsearch <- train(actual ~ .,             
                       data = train,               
                       method = 'rf',  
                       trControl = control, 
                       metric = 'RMSE',
                       tuneLength = 30) 

pred <- predict(rf_gridsearch, newdata = test)
print(RMSE(pred, test$actual))

```


## SVM로 검증 및 분석

-   SVM의 예측한계선을 설정하는 방법을 말하고 어떤 방법을 써야 하는지 기술
-   SVM를 활용해 예측 및 검증, 파라미터 튜닝으로 성능 강화
-   columns 별 중요도 시각화

```{r}

set.seed(123)
control <- trainControl(method='cv', 
                        number=5)


svm_gridsearch <- train(actual ~ .,             
                       data = train,               
                       method = 'svmPoly',  
                       trControl = control, 
                       metric = 'RMSE',
                       tuneLength = 10) 


pred <- predict(svm_gridsearch, newdata = test)
print(RMSE(pred, test$actual))


```



## 최적 모델 선택

-   SVM과 RF의 장단점 서술
-   두 모델 중 어떤 모델이 좋은지 고르고 이유 설명
-   선택한 모델의 한계점 서술 및 해결할 방법 서술

# 군집분석 {.tabset .tabset-fade}

-   7주 동안의 전력 소비량 데이터(15분 간격으로 측정)
-   year, month, day, 가구코드, 전력사용량


```{r}
library(ResidentialEnergyConsumption)
dat <- ResidentialEnergyConsumption::elcons_15min
dat <- dat$w44[1:50, ]
date <- seq(ymd_hm('2015-01-01 00:00'),ymd_hm('2015-01-07 23:45'), by = '15 mins')

dat <- dat %>% 
    pivot_longer(col = -VID, names_to = 'date', values_to = 'power') %>% 
    select(-date)

dat <- data.frame(date = rep(date, 50)) %>% 
    bind_cols(dat) %>% 
    mutate(year = year(date), 
           month = month(date), 
           day = day(date)) %>% 
    select(VID, date, year, month, day, power)

dat %>% is.na() %>% colSums()    

```

## clustering

-   table 만들기 

| 가구코드 | Date | 일사용량 total | Cluster |
|----------|------|------------------|---------|
|          |      |                  |         |
|          |      |                  |         |
|          |      |                  |         |


```{r}
result <- dat %>% 
    group_by(VID, year, month, day) %>% 
    summarise(total = sum(power, na.rm = T)) %>% 
    ungroup()

tot <- result %>% 
    select(total)

tot <- scale(tot)

set.seed(123)
km.res <- kmeans(tot, 5, nstart = 25)

result <- result %>% 
    bind_cols(km.res$cluster) %>% 
    rename(cluster = ...6)

result

```

```{r}

dat_p <- dat %>% 
    select(power)

dat_p <- scale(dat_p)

set.seed(123)
km.res <- kmeans(dat_p, 5, nstart = 25)

dat1 <- dat %>% 
    bind_cols(km.res$cluster) %>% 
    rename(cluster = ...7)

dat1

```

## Heatmap으로 시각화하기

|     |      |      |      |      |          |
|-----|------|------|------|------|----------|
|     | 1:15 | 1:30 | 1:45 | 2:00 | 2:15 ... |
| 월  |      |      |      |      |          |
| 화  |      |      |      |      |          |
| 수  |      |      |      |      |          |
| 목  |      |      |      |      |          |
| 금  |      |      |      |      |          |
| 토  |      |      |      |      |          |
| 일  |      |      |      |      |          |


```{r}

dat1 %>%
    filter(cluster == 4) %>%
    mutate(wday = wday(date, label = T), 
           hour = hour(date), 
           minute = minute(date)) %>%
    mutate(hour = as.character(hour),
           minute = as.character(minute), 
           ms = paste(hour, minute, sep = ":")) %>% 
    group_by(wday, ms) %>% 
    summarise(mean_w = mean(power)) %>% 
    ungroup() %>% 
    ggplot(aes(x = ms, y = wday, fill = mean_w)) + 
    geom_tile() + 
    scale_x_discrete(guide = guide_axis(n.dodge=7))

```



# 회귀 분석 모델링 {.tabset .tabset-fade}

## train/test 7:3으로 구분

## R2/RMSE/정확도 계산

-   정확도 : 실제값\>예측값인 경우 (1-예측값/실제값), 실제값\<예측값인 경우 (1-실제값/예측값) 결과를 평균내서 산출





